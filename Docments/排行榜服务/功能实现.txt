对业务层 提供排行榜服务

客户端接口:
1, 更新数据
2, 查询接口

管理端接口:
1, 初始化排行榜信息
	
	
2, 获取一个客户端接口
3, 刷新排行榜	(自动进行, 根据刷新策略)
4, 清除排行榜	清除旧排行榜数据
	
3, 刷新排行榜接口
	1, 获取所有排行榜的HostId集合 获取所有area集合中的元素。 
	2, 获取Host数据	
	3, 排序, 去除边界数据
	4, 刷新排行榜数据
	5, 清除旧排行榜数据
		a, preold -> old 数据
		b, 清除preold数据
		c, old ->now数据
				
	6, 生成新排行榜初始信息 是否重置数据
		a, 如果不重置数据, 需将排行榜的 排行信息和Host数据进行复制到新的Version上	OK
		b, 更新现在的排行状态信息	OK
		
	
4清除, 销毁过期排行榜数据信息
	a, 销毁Host数据	OK
	b, 销毁Host集合 OK
	c, 销毁Rank 排名数据 OK
			
	
	可以有没有数据修正的可能性。
	
	
全局写锁 获得 OK

SETNX lock tick+lockTime
1 
{
	获得锁
	
}

0
{
	Get lock
	
	lockTime > now
	{
		超时:
			GETSET 
		
	}else
	{
		锁定态:
	}
}


刷新策略:
	是否可以采用 ttl的方式 自动超时 排行榜数据信息? 在排行榜中

	
创建和销毁 交由客户端管理, 
	销毁带有自动销毁功能, 根据策略 永久排行榜？ 临时排行榜？
	
客户端接口
	注册
	
目前待解决的问题:
	1, 消息无序性 带来需要版本标签的问题	发散下对于CacheDB的支持, 混合DB？		目前采用 低分值不能更新高分值 进行
	2, 对于大榜和子榜较多的情况下, 不能对每个子榜 都有均等机会去刷新排行榜?			采用队列, 使每个榜能被更新到的频率一致
	3, 对于TTL的支持	TTL的粒度 分钟级别											
	4, 对于间隔刷新的一个抢占粒度？	根据间隔值 去构建一个粒度 最小值和最大值() 最小值 1S? 
	5, 对Cas如何进行测试?	未做
	6, 对定时刷新进行测试。	未做
	7, 对静态榜进行支撑		如果是静态榜 那么不刷新即可
	
	<12345667>

	大榜队列
	1 2	3 4	5
	1 1 1
    2 2 2
	3 	3
	4
		

目前 主线程的redis 频率过高。